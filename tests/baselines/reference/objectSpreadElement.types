=== tests/cases/conformance/es6/destructuring/objectSpreadElement.ts ===
let o = { a: 1, b: 'no' }
>o : { a: number; b: string; }
>{ a: 1, b: 'no' } : { a: number; b: string; }
>a : number
>1 : number
>b : string
>'no' : string

let o2 = { b: 'yes', c: true }
>o2 : { b: string; c: boolean; }
>{ b: 'yes', c: true } : { b: string; c: boolean; }
>b : string
>'yes' : string
>c : boolean
>true : boolean

let addAfter = { ...o, c: false }
>addAfter : { a: number; b: string; c: boolean; }
>{ ...o, c: false } : { a: number; b: string; c: boolean; }
>o : any
>c : boolean
>false : boolean

let addBefore = { c: false, ...o }
>addBefore : { c: boolean; a: number; b: string; }
>{ c: false, ...o } : { c: boolean; a: number; b: string; }
>c : boolean
>false : boolean
>o : any

// Note: ignore still changes the order that properties are printed
let ignore = { b: 'ignored', ...o }
>ignore : { b: string; a: number; }
>{ b: 'ignored', ...o } : { b: string; a: number; }
>b : string
>'ignored' : string
>o : any

let override = { ...o, b: 'override' }
>override : { a: number; b: string; }
>{ ...o, b: 'override' } : { a: number; b: string; }
>o : any
>b : string
>'override' : string

let nested = { ...{ a: 3, ...{ b: false, c: 'overriden' } }, c: 'whatever' }
>nested : { a: number; b: boolean; c: string; }
>{ ...{ a: 3, ...{ b: false, c: 'overriden' } }, c: 'whatever' } : { a: number; b: boolean; c: string; }
>{ a: 3, ...{ b: false, c: 'overriden' } } : { a: number; b: boolean; c: string; }
>a : number
>3 : number
>{ b: false, c: 'overriden' } : { b: boolean; c: string; }
>b : boolean
>false : boolean
>c : string
>'overriden' : string
>c : string
>'whatever' : string

let combined = { ...o, ...o2 }
>combined : { a: number; b: string; c: boolean; }
>{ ...o, ...o2 } : { a: number; b: string; c: boolean; }
>o : any
>o2 : any

let combinedBefore = { b: 'ok', ...o, ...o2 }
>combinedBefore : { b: string; a: number; c: boolean; }
>{ b: 'ok', ...o, ...o2 } : { b: string; a: number; c: boolean; }
>b : string
>'ok' : string
>o : any
>o2 : any

let combinedMid = { ...o, b: 'ok', ...o2 }
>combinedMid : { a: number; b: string; c: boolean; }
>{ ...o, b: 'ok', ...o2 } : { a: number; b: string; c: boolean; }
>o : any
>b : string
>'ok' : string
>o2 : any

let combinedAfter = { ...o, ...o2, b: 'ok' }
>combinedAfter : { a: number; b: string; c: boolean; }
>{ ...o, ...o2, b: 'ok' } : { a: number; b: string; c: boolean; }
>o : any
>o2 : any
>b : string
>'ok' : string

let combinedNested = {
>combinedNested : { a: number; b: boolean; c: string; d: string; }
>{    ...{ a: 4, ...{ b: false, c: 'overriden' } },    d: 'actually new',    ...{ a: 5, d: 'maybe new' },} : { a: number; b: boolean; c: string; d: string; }

    ...{ a: 4, ...{ b: false, c: 'overriden' } },
>{ a: 4, ...{ b: false, c: 'overriden' } } : { a: number; b: boolean; c: string; }
>a : number
>4 : number
>{ b: false, c: 'overriden' } : { b: boolean; c: string; }
>b : boolean
>false : boolean
>c : string
>'overriden' : string

    d: 'actually new',
>d : string
>'actually new' : string

    ...{ a: 5, d: 'maybe new' },
>{ a: 5, d: 'maybe new' } : { a: number; d: string; }
>a : number
>5 : number
>d : string
>'maybe new' : string
}
// accessors don't copy the descriptor
// (which means that readonly getters become read/write)
let op = { get a () { return 6 } };
>op : { readonly a: number; }
>{ get a () { return 6 } } : { readonly a: number; }
>a : number
>6 : number

let getter = { ...op, c: 7 }
>getter : { a: number; c: number; }
>{ ...op, c: 7 } : { a: number; c: number; }
>op : any
>c : number
>7 : number

// null and undefined are just skipped
let spreadNull = { ...null }
>spreadNull : {}
>{ ...null } : {}
>null : null

let spreadUndefined = { ...undefined }
>spreadUndefined : {}
>{ ...undefined } : {}
>undefined : any

// methods are not enumerable
class C { m() { } };
>C : C
>m : () => void

let c: C = new C();
>c : C
>C : C
>new C() : C
>C : typeof C

let spreadC = {...c};
>spreadC : {}
>{...c} : {}
>c : any

