=== tests/cases/conformance/types/contextualTypes/methodDeclarations/contextuallyTypedBindingInitializer.ts ===
interface Show {
>Show : Show

    show: (x: number) => string;
>show : (x: number) => string
>x : number
}
function f({ show = v => v.toString() }: Show) {}
>f : ({ show = v => v.toString() }: Show) => void
>show : (x: number) => string
>v => v.toString() : (v: number) => string
>v : number
>v.toString() : string
>v.toString : (radix?: number) => string
>v : number
>toString : (radix?: number) => string
>Show : Show

interface Nested {
>Nested : Nested

    nested: Show
>nested : Show
>Show : Show
}
function ff({ nested = { show: v => v.toString() } }: Nested) {}
>ff : ({ nested = { show: v => v.toString() } }: Nested) => void
>nested : Show
>{ show: v => v.toString() } : { show: (v: number) => string; }
>show : (v: number) => string
>v => v.toString() : (v: number) => string
>v : number
>v.toString() : string
>v.toString : (radix?: number) => string
>v : number
>toString : (radix?: number) => string
>Nested : Nested

interface Tuples {
>Tuples : Tuples

    prop: [string, number];
>prop : [string, number]
}
function g({ prop = ["hello", 1234] }: Tuples) {}
>g : ({ prop = ["hello", 1234] }: Tuples) => void
>prop : [string, number]
>["hello", 1234] : [string, number]
>"hello" : string
>1234 : number
>Tuples : Tuples

interface StringUnion {
>StringUnion : StringUnion

    prop: "foo" | "bar";
>prop : "foo" | "bar"
}
function h({ prop = "foo" }: StringUnion) {}
>h : ({ prop = "foo" }: StringUnion) => void
>prop : "foo" | "bar"
>"foo" : "foo"
>StringUnion : StringUnion

